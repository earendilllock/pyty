#+STARTUP: overview
#+STARTUP: hidestars
#+OPTIONS: LaTeX:t
#+OPTIONS: toc:nil
#+LaTeX_CLASS: per-file-class
#+TITLE: Каноническая аппроксимация тензоров и ее реализация на Python
#+AUTHOR: Кузнецов М.А.
#+DATE: 
* LATEX OPTIONS 						   :noexport:
#+OPTIONS: toc:nil
** Packages
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[english,russian]{babel}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amsfonts,amsmath,amssymb}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{algorithmic} \usepackage[ruled]{algorithm}
#+LATEX_HEADER: \usepackage[unicode=true,plainpages=false]{hyperref}
#+LATEX_HEADER: \hypersetup{colorlinks=true,linkcolor=magenta,anchorcolor=magenta,urlcolor=blue,citecolor=blue}
** User-defined symbols
#+LATEX_HEADER: \def\A{\mathbf{A}}
#+LATEX_HEADER: \def\V{\mathbf{V}}
#+LATEX_HEADER: \def\B{\mathbf{B}}
#+LATEX_HEADER: \def\C{\mathbf{C}}
** GeometryTEX_HEADER: \usepackage[a4paper]{geometry}




   

 
   
* Введение
     
  Аппроксимация многомерных массивов играет важную роль в приложениях. Однако вместо заданного многомерного массива
часто нужно пользоваться его приближением, свойства которого известны, возможно. в отличие от заданного.
Такие аппроксимации удобно строить используя следующее представление многомерного массива (/тензора/)

 /Определение/
  
 Тензором A размерности $d$ назовем многомерный массив, элементы которого A(i_1,i_2,\ldots,i_d) имеют $d$ 
индексов.

 /Определение/

 Каноническим разложением многомерного массива (/тензора/) 
называется представление вида 

\begin{equation}\label{curs:eq1}
A(i_1,i_2,\ldots,i_d) = \sum_{\alpha=1}^r U_1(i_1,\alpha) U_2(i_2,\alpha) \ldots U_d(i_d,\alpha),
\end{equation}
где U_k называются /факторами/ канонического разложения, а $r$ --- каноническим рангом.

Уравнение \eqref{curs:eq1} является основным.

* Численные эксперименты
 В данном параграфе будут изложены в графическом виде результаты работы программы, реализующей метод ALS. 
В качестве входных данных подавались:
 - Размерность тензора $d$ = 3
 - Ранг $r$ переменный
 - Размерности мод $dimension_i$ переменные
** Численные эксперименты для случайных тензоров
 В качестве входного тензора подается тензор, случайным образом полученный программно (с помощью процедуры
gettensor) наперед заданного ранга и размерностей мод. 

Первый цикл экспериментов призван был установить характер поведения нормы невязки 
\begin{equation}\label{curs:eq2}
max|A(i_1,i_2,i_3)-Approximation(i_1,i_2,i_3)|
\end{equation}

где Approximation(i_1,i_2,i_3) --- аппроксимация заданного тензора, построенная с помощью алгоритма
ALS, реализованного на Python.

Ниже приводятся графики поведения нормы невязки (\eq2) в зависимости от числа итераций. 
- Для случайного тензора ранга $r$ = 5
#+attr_latex: width=8cm
[[file:/home/earendilllock/pyty/RandTr5.png]]

- Для случайного тензора ранга $r$ = 10

На этом примере метод попал в локальный минимум функционала (\eq2), вследствии чего невязка убывает медленно почти
на всем протяжении времени работы алгоритма. Однако миновав локальный минимум, метод сошелся очень быстро.
#+attr_latex: width=8cm
#+name: pic1
[[file:/home/earendilllock/pyty/RandomTensorr10.pdf]]
- Для случайного тензора ранга $r$ = 25
#+attr_latex: width=8cm
[[file:/home/earendilllock/pyty/RandTr25.png]]
- Для случайного тензора ранга $r$ = 100
#+attr_latex: width=8cm
#+name: pic1
[[file:/home/earendilllock/pyty/RandTr100.png]]

Несмотря на то, что скорость убывания невязки может варьироваться в зависимости от ранга и начального приближения,
невязка убывает монотонно.

Следующая серия экспериментов показывает нрафическую зависимость времени выполнения программы от:
- ранга $r$ при фиксированных размерностях тензора
 

#+attr_latex: width=8cm
#+name: "Ранг" 
[[file:/home/earendilllock/pyty/timeotrang.png]]

в ходе этого эксперимента размерности мод $dimension_i$ брались равными между собой и равными 32 а ранг 
менялся $r$ = 2,3,5,10,25,50,100,500. Исходя из графика, можно сделать вывод, что время зависит от ранга 
как O(r)
  
- размерностей тензора $dimension_i$ (i = 1,\ldots,3) при фиксированном ранге
  Эта серия экспериментов проводилась с целью изучения зависимости времени выполнения программы от размерностей мод
$dimension_i$ = 32,64,128,250,500 и ранге $r$ = 5.

#+attr_latex: width=8cm
#+name: "Ранг" 
[[file:/home/earendilllock/pyty/timeotdim.png]]

Судя по графику время выполнения программы пропорционально O(n^1^,^2)


